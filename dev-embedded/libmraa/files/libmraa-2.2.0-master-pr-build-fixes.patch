From cb460db0298d4c3af5efa7f4f309a71aa9b51413 Mon Sep 17 00:00:00 2001
From: Chuckduey <cduey@msn.com>
Date: Mon, 28 Dec 2020 14:49:09 -0700
Subject: [PATCH] Roll-up patch from upstream +compiler warning PR

api: Add explicit close methods to classes
include: Declare gVERSION global as 'extern'.
aio: Update shifter_value and max_analog_value on mraa_aio_set_bit
iio: Add missing parameter in error log output
iio: Silence format-truncation warnings
python3: Drop bogus CMAKE_C_FLAGS
gpio: Silence own use of deprecated mraa_gpio_use_mmaped
---
 api/mraa/aio.hpp                  |  11 +
 api/mraa/gpio.h                   |   3 +
 api/mraa/gpio.hpp                 |  13 +-
 api/mraa/i2c.hpp                  |  12 +
 api/mraa/iio.hpp                  |  13 +-
 api/mraa/led.hpp                  |  12 +
 api/mraa/pwm.hpp                  |  11 +
 api/mraa/spi.hpp                  |  12 +
 api/mraa/types.h                  |   1 +
 api/mraa/uart.h                   |   8 +-
 api/mraa/uart.hpp                 |  12 +
 api/mraa/uart_ow.hpp              |  12 +
 examples/c/pwm.c                  |   2 +-
 examples/c/spi.c                  |   2 +-
 examples/c/uart_advanced.c        |  12 +-
 include/arm/raspberry_pi.h        |   1 +
 include/mraa_internal_types.h     |   3 +-
 include/version.h                 |   4 +-
 include/x86/intel_ilk.h           |  24 ++
 src/CMakeLists.txt                |   2 +
 src/aio/aio.c                     |  24 +-
 src/arm/raspberry_pi.c            |  15 +-
 src/gpio/gpio.c                   | 104 ++++---
 src/iio/iio.c                     |   2 +-
 src/led/led.c                     |  60 ++--
 src/python/python3/CMakeLists.txt |   2 +-
 src/uart/uart.c                   |  22 +-
 src/x86/intel_ilk.c               | 439 ++++++++++++++++++++++++++++++
 src/x86/x86.c                     |   4 +
 tools/mraa-gpio.c                 |   4 +-
 tools/mraa-uart.c                 |   2 +-
 31 files changed, 727 insertions(+), 121 deletions(-)
 create mode 100644 include/x86/intel_ilk.h
 create mode 100644 src/x86/intel_ilk.c

diff --git a/api/mraa/aio.hpp b/api/mraa/aio.hpp
index f880b64..2db385f 100644
--- a/api/mraa/aio.hpp
+++ b/api/mraa/aio.hpp
@@ -75,8 +75,19 @@ class Aio
      * Aio destructor
      */
     ~Aio()
+    {
+        if (m_aio != NULL) {
+            mraa_aio_close(m_aio);
+        }
+    }
+    /**
+     * Closes AIO explicitly, prior to implicit closing on object destruction
+     */
+    void
+    close()
     {
         mraa_aio_close(m_aio);
+        m_aio = NULL;
     }
     /**
      * Read a value from the AIO pin. By default mraa will shift
diff --git a/api/mraa/gpio.h b/api/mraa/gpio.h
index 5973632..ce48f82 100644
--- a/api/mraa/gpio.h
+++ b/api/mraa/gpio.h
@@ -288,6 +288,9 @@ mraa_result_t mraa_gpio_owner(mraa_gpio_context dev, mraa_boolean_t owner);
  */
 DEPRECATED mraa_result_t mraa_gpio_use_mmaped(mraa_gpio_context dev, mraa_boolean_t mmap);
 
+/* remaining internal use only */
+mraa_result_t mraa_gpio_use_mmaped_internal(mraa_gpio_context dev, mraa_boolean_t mmap);
+
 /**
  * Get a pin number of the gpio, invalid will return -1
  *
diff --git a/api/mraa/gpio.hpp b/api/mraa/gpio.hpp
index 07ca03e..c0b546c 100644
--- a/api/mraa/gpio.hpp
+++ b/api/mraa/gpio.hpp
@@ -143,8 +143,19 @@ class Gpio
      * the owner
      */
     ~Gpio()
+    {
+        if (m_gpio != NULL) {
+            mraa_gpio_close(m_gpio);
+        }
+    }
+    /**
+     * Closes Gpio explicitly, prior to implicit closing on object destruction
+     */
+    void
+    close()
     {
         mraa_gpio_close(m_gpio);
+        m_gpio = NULL;
     }
     /**
      * Set the edge mode for ISR
@@ -316,7 +327,7 @@ class Gpio
     Result
     useMmap(bool enable)
     {
-        return (Result) mraa_gpio_use_mmaped(m_gpio, (mraa_boolean_t) enable);
+        return (Result) mraa_gpio_use_mmaped_internal(m_gpio, (mraa_boolean_t) enable);
     }
     /**
      * Get pin number of Gpio. If raw param is True will return the
diff --git a/api/mraa/i2c.hpp b/api/mraa/i2c.hpp
index cc26b15..cf52b77 100644
--- a/api/mraa/i2c.hpp
+++ b/api/mraa/i2c.hpp
@@ -83,8 +83,20 @@ class I2c
      * slaves.
      */
     ~I2c()
+    {
+        if (m_i2c != NULL) {
+            mraa_i2c_stop(m_i2c);
+        }
+    }
+
+    /**
+     * Closes I2c explicitly, prior to implicit closing on object destruction
+     */
+    void
+    close()
     {
         mraa_i2c_stop(m_i2c);
+        m_i2c = NULL;
     }
 
     /**
diff --git a/api/mraa/iio.hpp b/api/mraa/iio.hpp
index f9d8ff4..c1f2c67 100644
--- a/api/mraa/iio.hpp
+++ b/api/mraa/iio.hpp
@@ -131,9 +131,20 @@ class Iio
      */
     ~Iio()
     {
-        mraa_iio_close(m_iio);
+        if (m_iio != NULL) {
+            mraa_iio_close(m_iio);
+        }
     }
 
+    /**
+     * Closes Iio explicitly, prior to implicit closing on object destruction
+     */
+    void
+    close()
+    {
+        mraa_iio_close(m_iio);
+        m_iio = NULL;
+    }
 
     /**
      * Get device name
diff --git a/api/mraa/led.hpp b/api/mraa/led.hpp
index 8adc789..903823f 100644
--- a/api/mraa/led.hpp
+++ b/api/mraa/led.hpp
@@ -89,8 +89,20 @@ class Led
      * LED object destructor
      */
     ~Led()
+    {
+        if (m_led != NULL) {
+            mraa_led_close(m_led);
+        }
+    }
+
+    /*
+     * Closes LED explicitly, prior to implicit closing on object destruction
+     */
+    void
+    close()
     {
         mraa_led_close(m_led);
+        m_led = NULL;
     }
 
     /**
diff --git a/api/mraa/pwm.hpp b/api/mraa/pwm.hpp
index 4bdfa71..66da1f3 100644
--- a/api/mraa/pwm.hpp
+++ b/api/mraa/pwm.hpp
@@ -86,8 +86,19 @@ class Pwm
      * Pwm destructor
      */
     ~Pwm()
+    {
+        if (m_pwm != NULL) {
+            mraa_pwm_close(m_pwm);
+        }
+    }
+    /*
+     * Closes Pwm explicitly, prior to implicit closing on object destruction
+     */
+    void
+    close()
     {
         mraa_pwm_close(m_pwm);
+        m_pwm = NULL;
     }
     /**
      * Set the output duty-cycle percentage, as a float
diff --git a/api/mraa/spi.hpp b/api/mraa/spi.hpp
index 26ead24..aa9d69d 100644
--- a/api/mraa/spi.hpp
+++ b/api/mraa/spi.hpp
@@ -105,8 +105,20 @@ class Spi
      * Closes spi bus
      */
     ~Spi()
+    {
+        if (m_spi != NULL) {
+            mraa_spi_stop(m_spi);
+        }
+    }
+
+    /**
+     * Closes Spi explicitly, prior to implicit closing on object destruction
+     */
+    void
+    close()
     {
         mraa_spi_stop(m_spi);
+        m_spi = NULL;
     }
 
     /**
diff --git a/api/mraa/types.h b/api/mraa/types.h
index c1fc288..00fca5e 100644
--- a/api/mraa/types.h
+++ b/api/mraa/types.h
@@ -67,6 +67,7 @@ typedef enum {
     MRAA_ADLINK_LEC_AL = 22,        /**< Adlink LEC-AL*/
     MRAA_ADLINK_LEC_AL_AI = 23,        /**< Adlink LEC-AL*/
     MRAA_UPXTREME = 24,             /**< The UPXTREME Board */
+    MRAA_INTEL_ILK = 25,            /**< Intel Learning Kit */
     // USB platform extenders start at 256
     MRAA_FTDI_FT4222 = 256,         /**< FTDI FT4222 USB to i2c bridge */
 
diff --git a/api/mraa/uart.h b/api/mraa/uart.h
index 3495b2f..64835a8 100644
--- a/api/mraa/uart.h
+++ b/api/mraa/uart.h
@@ -171,8 +171,8 @@ const char* mraa_uart_get_dev_path(mraa_uart_context dev);
  * @param databits pointer to an integer to contain the number databits (5--8)
  * @param stopbits pointer to an integer to contain the number stopbits (1--2)
  * @param parity will contain the current parity mode
- * @param rtscts will point to non-zero if CTS/RTS flow control is enabled, zero otherwise
- * @param xonxoff will point to a non-zero value if xon/xoff flow control is enabled
+ * @param rtscts will point to true if CTS/RTS flow control is enabled
+ * @param xonxoff will point to a true if xon/xoff flow control is enabled
  * @return result
  */
 mraa_result_t
@@ -183,8 +183,8 @@ mraa_uart_settings(int index,
     int* databits,
     int* stopbits,
     mraa_uart_parity_t* parity,
-    unsigned int* rtscts,
-    unsigned int* xonxoff);
+    mraa_boolean_t* rtscts,
+    mraa_boolean_t* xonxoff);
 
 /**
  * Destroy a mraa_uart_context
diff --git a/api/mraa/uart.hpp b/api/mraa/uart.hpp
index e9624db..056b690 100644
--- a/api/mraa/uart.hpp
+++ b/api/mraa/uart.hpp
@@ -95,8 +95,20 @@ class Uart
      * Uart destructor
      */
     ~Uart()
+    {
+        if (m_uart != NULL) {
+            mraa_uart_stop(m_uart);
+        }
+    }
+
+    /*
+     * Closes Uart explicitly, prior to implicit closing on object destruction
+     */
+    void
+    close()
     {
         mraa_uart_stop(m_uart);
+        m_uart = NULL;
     }
 
     /**
diff --git a/api/mraa/uart_ow.hpp b/api/mraa/uart_ow.hpp
index db44e9d..e64a14a 100644
--- a/api/mraa/uart_ow.hpp
+++ b/api/mraa/uart_ow.hpp
@@ -95,8 +95,20 @@ class UartOW
      * Uart destructor
      */
     ~UartOW()
+    {
+        if (m_uart != NULL) {
+            mraa_uart_ow_stop(m_uart);
+        }
+    }
+
+    /*
+     * Closes UartOW explicitly, prior to implicit closing on object destruction
+     */
+    void
+    close()
     {
         mraa_uart_ow_stop(m_uart);
+        m_uart = NULL;
     }
 
     /**
diff --git a/examples/c/pwm.c b/examples/c/pwm.c
index 629d824..481433b 100644
--- a/examples/c/pwm.c
+++ b/examples/c/pwm.c
@@ -6,7 +6,7 @@
  * SPDX-License-Identifier: MIT
  *
  * Example usage: Generates PWM signal of period 200us with variable dutycyle
- *                repeately. Press Ctrl+C to exit
+ *                repeatedly. Press Ctrl+C to exit
  */
 
 /* standard headers */
diff --git a/examples/c/spi.c b/examples/c/spi.c
index f0290a1..8e5530a 100644
--- a/examples/c/spi.c
+++ b/examples/c/spi.c
@@ -6,7 +6,7 @@
  *
  * SPDX-License-Identifier: MIT
  *
- * Example usage: Display set of patterns on MAX7219 repeately.
+ * Example usage: Display set of patterns on MAX7219 repeatedly.
  *                Press Ctrl+C to exit
  */
 
diff --git a/examples/c/uart_advanced.c b/examples/c/uart_advanced.c
index 140408d..002491e 100644
--- a/examples/c/uart_advanced.c
+++ b/examples/c/uart_advanced.c
@@ -46,7 +46,6 @@ main(int argc, char** argv)
     int baudrate = 9600, stopbits = 1, databits = 8;
     mraa_uart_parity_t parity = MRAA_UART_PARITY_NONE;
     unsigned int ctsrts = FALSE, xonxoff = FALSE;
-    const char* name = NULL;
 
     /* install signal handler */
     signal(SIGINT, sig_handler);
@@ -63,8 +62,15 @@ main(int argc, char** argv)
     }
 
     /* set serial port parameters */
-    status =
-    mraa_uart_settings(-1, &dev_path, &name, &baudrate, &databits, &stopbits, &parity, &ctsrts, &xonxoff);
+    status = mraa_uart_set_baudrate(uart, baudrate);
+    if (status != MRAA_SUCCESS) {
+        goto err_exit;
+    }
+    status = mraa_uart_set_mode(uart, databits, parity, stopbits);
+    if (status != MRAA_SUCCESS) {
+        goto err_exit;
+    }
+    status = mraa_uart_set_flowcontrol(uart, xonxoff, ctsrts);
     if (status != MRAA_SUCCESS) {
         goto err_exit;
     }
diff --git a/include/arm/raspberry_pi.h b/include/arm/raspberry_pi.h
index 31b1f54..349857f 100644
--- a/include/arm/raspberry_pi.h
+++ b/include/arm/raspberry_pi.h
@@ -25,6 +25,7 @@ extern "C" {
 #define MRAA_RASPBERRY_PI3_B_PLUS_PINCOUNT 41
 #define MRAA_RASPBERRY_PI3_A_PLUS_PINCOUNT 41
 #define MRAA_RASPBERRY_PI4_B_PINCOUNT 41
+#define MRAA_RASPBERRY_PI_400_PINCOUNT 41
 
 mraa_board_t *
         mraa_raspberry_pi();
diff --git a/include/mraa_internal_types.h b/include/mraa_internal_types.h
index 207666a..882ce4a 100644
--- a/include/mraa_internal_types.h
+++ b/include/mraa_internal_types.h
@@ -273,8 +273,7 @@ struct _iio {
 struct _led {
     /*@{*/
     int count; /**< total LED count in a platform */
-    char *led_name; /**< LED name */
-    char led_path[64]; /**< sysfs path of the LED */
+    const char *led_path; /**< sysfs path of the LED */
     int trig_fd; /**< trigger file descriptor */
     int bright_fd; /**< brightness file descriptor */
     int max_bright_fd; /**< maximum brightness file descriptor */
diff --git a/include/version.h b/include/version.h
index 47366ef..3a567a1 100644
--- a/include/version.h
+++ b/include/version.h
@@ -11,8 +11,8 @@
 extern "C" {
 #endif
 
-const char* gVERSION;
-const char* gVERSION_SHORT;
+extern const char* gVERSION;
+extern const char* gVERSION_SHORT;
 
 #ifdef __cplusplus
 }
diff --git a/include/x86/intel_ilk.h b/include/x86/intel_ilk.h
new file mode 100644
index 0000000..3cd98f6
--- /dev/null
+++ b/include/x86/intel_ilk.h
@@ -0,0 +1,24 @@
+/*
+ * Author: Jeet Arora <jeet.arora@intel.com>
+ * Copyright (c) 2021 Intel Corporation.
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+#pragma once
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "mraa_internal.h"
+
+// +1 as pins are "1 indexed"
+#define MRAA_INTEL_ILK_PINCOUNT (40 + 1)
+
+mraa_board_t*
+mraa_intel_ilk();
+
+#ifdef __cplusplus
+}
+#endif
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 6cfb72e..aa983f4 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -39,6 +39,7 @@ if (NOT PERIPHERALMAN)
     ${mraa_LIB_SRCS_NOAUTO}
     ${PROJECT_SOURCE_DIR}/src/iio/iio.c
   )
+  set_source_files_properties(${PROJECT_SOURCE_DIR}/src/iio/iio.c PROPERTIES COMPILE_OPTIONS "-Wno-format-truncation")
 endif ()
 
 set (mraa_LIB_X86_SRCS_NOAUTO
@@ -51,6 +52,7 @@ set (mraa_LIB_X86_SRCS_NOAUTO
   ${PROJECT_SOURCE_DIR}/src/x86/intel_minnow_byt_compatible.c
   ${PROJECT_SOURCE_DIR}/src/x86/intel_sofia_3gr.c
   ${PROJECT_SOURCE_DIR}/src/x86/intel_cherryhills.c
+  ${PROJECT_SOURCE_DIR}/src/x86/intel_ilk.c
   ${PROJECT_SOURCE_DIR}/src/x86/up.c
   ${PROJECT_SOURCE_DIR}/src/x86/up2.c
   ${PROJECT_SOURCE_DIR}/src/x86/intel_joule_expansion.c
diff --git a/src/aio/aio.c b/src/aio/aio.c
index 0cc631f..753aff8 100644
--- a/src/aio/aio.c
+++ b/src/aio/aio.c
@@ -126,7 +126,9 @@ mraa_aio_init(unsigned int aio)
         syslog(LOG_ERR, "aio: Insufficient memory for specified input channel %d", aio);
         return NULL;
     }
-    dev->value_bit = DEFAULT_BITS;
+
+    raw_bits = mraa_adc_raw_bits();
+    mraa_aio_set_bit(dev, DEFAULT_BITS);
 
     if (IS_FUNC_DEFINED(dev, aio_init_pre)) {
         mraa_result_t pre_ret = (dev->advance_func->aio_init_pre(aio));
@@ -144,16 +146,6 @@ mraa_aio_init(unsigned int aio)
         }
     }
 
-    raw_bits = mraa_adc_raw_bits();
-
-    if (raw_bits < dev->value_bit) {
-        shifter_value = dev->value_bit - raw_bits;
-        max_analog_value = ((1 << raw_bits) - 1) << shifter_value;
-    } else {
-        shifter_value = raw_bits - dev->value_bit;
-        max_analog_value = ((1 << raw_bits) - 1) >> shifter_value;
-    }
-
     return dev;
 }
 
@@ -247,7 +239,17 @@ mraa_aio_set_bit(mraa_aio_context dev, int bits)
         syslog(LOG_ERR, "aio: Device not valid");
         return MRAA_ERROR_INVALID_RESOURCE;
     }
+
     dev->value_bit = bits;
+
+    if (raw_bits < dev->value_bit) {
+        shifter_value = dev->value_bit - raw_bits;
+        max_analog_value = ((1 << raw_bits) - 1) << shifter_value;
+    } else {
+        shifter_value = raw_bits - dev->value_bit;
+        max_analog_value = ((1 << raw_bits) - 1) >> shifter_value;
+    }
+
     return MRAA_SUCCESS;
 }
 
diff --git a/src/arm/raspberry_pi.c b/src/arm/raspberry_pi.c
index 172217d..bda8731 100644
--- a/src/arm/raspberry_pi.c
+++ b/src/arm/raspberry_pi.c
@@ -29,6 +29,7 @@
 #define PLATFORM_NAME_RASPBERRY_PI3_B_PLUS "Raspberry Pi 3 Model B+"
 #define PLATFORM_NAME_RASPBERRY_PI3_A_PLUS "Raspberry Pi 3 Model A+"
 #define PLATFORM_NAME_RASPBERRY_PI4_B "Raspberry Pi 4 Model B"
+#define PLATFORM_NAME_RASPBERRY_PI_400 "Raspberry Pi 400"
 #define PLATFORM_RASPBERRY_PI_B_REV_1 1
 #define PLATFORM_RASPBERRY_PI_A_REV_2 2
 #define PLATFORM_RASPBERRY_PI_B_REV_2 3
@@ -42,6 +43,7 @@
 #define PLATFORM_RASPBERRY_PI3_B_PLUS 11
 #define PLATFORM_RASPBERRY_PI3_A_PLUS 12
 #define PLATFORM_RASPBERRY_PI4_B 13
+#define PLATFORM_RASPBERRY_PI_400 14
 #define MMAP_PATH "/dev/mem"
 #define BCM2835_PERI_BASE 0x20000000
 #define BCM2836_PERI_BASE 0x3f000000
@@ -513,6 +515,12 @@ mraa_raspberry_pi()
                     b->phy_pin_count = MRAA_RASPBERRY_PI4_B_PINCOUNT;
                     peripheral_base = BCM2837_PERI_BASE;
                     block_size = BCM2837_BLOCK_SIZE;
+                } else if (strstr(line, "c03130")) {
+                    b->platform_name = PLATFORM_NAME_RASPBERRY_PI_400;
+                    platform_detected = PLATFORM_RASPBERRY_PI_400;
+                    b->phy_pin_count = MRAA_RASPBERRY_PI_400_PINCOUNT;
+                    peripheral_base = BCM2837_PERI_BASE;
+                    block_size = BCM2837_BLOCK_SIZE;
                 } else {
                     b->platform_name = PLATFORM_NAME_RASPBERRY_PI_B_REV_1;
                     platform_detected = PLATFORM_RASPBERRY_PI_B_REV_1;
@@ -587,6 +595,10 @@ mraa_raspberry_pi()
             b->platform_name = PLATFORM_NAME_RASPBERRY_PI4_B;
             platform_detected = PLATFORM_RASPBERRY_PI4_B;
             b->phy_pin_count = MRAA_RASPBERRY_PI4_B_PINCOUNT;
+        } else if (mraa_file_contains(compatible_path, "raspberrypi,4-model-bbrcm")) {
+            b->platform_name = PLATFORM_NAME_RASPBERRY_PI_400;
+            platform_detected = PLATFORM_RASPBERRY_PI_400;
+            b->phy_pin_count = MRAA_RASPBERRY_PI_400_PINCOUNT;
         }
     }
 
@@ -856,7 +868,8 @@ mraa_raspberry_pi()
         (platform_detected == PLATFORM_RASPBERRY_PI_ZERO_W) ||
         (platform_detected == PLATFORM_RASPBERRY_PI3_B_PLUS) ||
         (platform_detected == PLATFORM_RASPBERRY_PI3_A_PLUS) ||
-        (platform_detected == PLATFORM_RASPBERRY_PI4_B)) {
+        (platform_detected == PLATFORM_RASPBERRY_PI4_B) ||
+        (platform_detected == PLATFORM_RASPBERRY_PI_400)) {
 
         strncpy(b->pins[27].name, "ID_SD", MRAA_PIN_NAME_SIZE);
         b->pins[27].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
diff --git a/src/gpio/gpio.c b/src/gpio/gpio.c
index d1a41ad..62ffe9a 100644
--- a/src/gpio/gpio.c
+++ b/src/gpio/gpio.c
@@ -1218,6 +1218,31 @@ mraa_gpio_chardev_dir(mraa_gpio_context dev, mraa_gpio_dir_t dir)
     return MRAA_SUCCESS;
 }
 
+static mraa_result_t
+gpio_sysfs_read_dir(mraa_gpio_context dev, int dir_fd, mraa_gpio_dir_t *dir)
+{
+    char value[5];
+    int rc;
+
+    memset(value, '\0', sizeof(value));
+    rc = read(dir_fd, value, sizeof(value));
+    if (rc <= 0) {
+        syslog(LOG_ERR, "gpio%i: read_dir: Failed to read 'direction': %s", dev->pin, strerror(errno));
+        return MRAA_ERROR_INVALID_RESOURCE;
+    }
+
+    if (strcmp(value, "out\n") == 0) {
+        *dir = MRAA_GPIO_OUT;
+    } else if (strcmp(value, "in\n") == 0) {
+        *dir = MRAA_GPIO_IN;
+    } else {
+        syslog(LOG_ERR, "gpio%i: read_dir: unknown direction: %s", dev->pin, value);
+        return MRAA_ERROR_UNSPECIFIED;
+    }
+
+    return MRAA_SUCCESS;
+}
+
 mraa_result_t
 mraa_gpio_dir(mraa_gpio_context dev, mraa_gpio_dir_t dir)
 {
@@ -1267,30 +1292,38 @@ mraa_gpio_dir(mraa_gpio_context dev, mraa_gpio_dir_t dir)
             }
         }
 
-        char bu[MAX_SIZE];
-        int length;
-        switch (dir) {
-            case MRAA_GPIO_OUT:
-                length = snprintf(bu, sizeof(bu), "out");
-                break;
-            case MRAA_GPIO_IN:
-                length = snprintf(bu, sizeof(bu), "in");
-                break;
-            case MRAA_GPIO_OUT_HIGH:
-                length = snprintf(bu, sizeof(bu), "high");
-                break;
-            case MRAA_GPIO_OUT_LOW:
-                length = snprintf(bu, sizeof(bu), "low");
-                break;
-            default:
-                close(direction);
-                return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+        mraa_gpio_dir_t cur_dir;
+        mraa_result_t result = gpio_sysfs_read_dir(dev, direction, &cur_dir);
+        if (result != MRAA_SUCCESS) {
+            return result;
         }
 
-        if (write(direction, bu, length * sizeof(char)) == -1) {
-            close(direction);
-            syslog(LOG_ERR, "gpio%i: dir: Failed to write to 'direction': %s", it->pin, strerror(errno));
-            return MRAA_ERROR_UNSPECIFIED;
+        if (cur_dir != dir) {
+            char bu[MAX_SIZE];
+            int length;
+            switch (dir) {
+                case MRAA_GPIO_OUT:
+                    length = snprintf(bu, sizeof(bu), "out");
+                    break;
+                case MRAA_GPIO_IN:
+                    length = snprintf(bu, sizeof(bu), "in");
+                    break;
+                case MRAA_GPIO_OUT_HIGH:
+                    length = snprintf(bu, sizeof(bu), "high");
+                    break;
+                case MRAA_GPIO_OUT_LOW:
+                    length = snprintf(bu, sizeof(bu), "low");
+                    break;
+                default:
+                    close(direction);
+                    return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
+            }
+
+            if (write(direction, bu, length * sizeof(char)) == -1) {
+                close(direction);
+                syslog(LOG_ERR, "gpio%i: dir: Failed to write to 'direction': %s", it->pin, strerror(errno));
+                return MRAA_ERROR_UNSPECIFIED;
+            }
         }
 
         close(direction);
@@ -1340,9 +1373,8 @@ mraa_gpio_read_dir(mraa_gpio_context dev, mraa_gpio_dir_t* dir)
 
         *dir = flags & GPIOLINE_FLAG_IS_OUT ? MRAA_GPIO_OUT : MRAA_GPIO_IN;
     } else {
-        char value[5];
         char filepath[MAX_SIZE];
-        int fd, rc;
+        int fd;
 
         if (dev == NULL) {
             syslog(LOG_ERR, "gpio: read_dir: context is invalid");
@@ -1362,22 +1394,8 @@ mraa_gpio_read_dir(mraa_gpio_context dev, mraa_gpio_dir_t* dir)
             return MRAA_ERROR_INVALID_RESOURCE;
         }
 
-        memset(value, '\0', sizeof(value));
-        rc = read(fd, value, sizeof(value));
+        result = gpio_sysfs_read_dir(dev, fd, dir);
         close(fd);
-        if (rc <= 0) {
-            syslog(LOG_ERR, "gpio%i: read_dir: Failed to read 'direction': %s", dev->pin, strerror(errno));
-            return MRAA_ERROR_INVALID_RESOURCE;
-        }
-
-        if (strcmp(value, "out\n") == 0) {
-            *dir = MRAA_GPIO_OUT;
-        } else if (strcmp(value, "in\n") == 0) {
-            *dir = MRAA_GPIO_IN;
-        } else {
-            syslog(LOG_ERR, "gpio%i: read_dir: unknown direction: %s", dev->pin, value);
-            result = MRAA_ERROR_UNSPECIFIED;
-        }
     }
 
     return result;
@@ -1722,7 +1740,7 @@ mraa_gpio_owner(mraa_gpio_context dev, mraa_boolean_t own)
 }
 
 mraa_result_t
-mraa_gpio_use_mmaped(mraa_gpio_context dev, mraa_boolean_t mmap_en)
+mraa_gpio_use_mmaped_internal(mraa_gpio_context dev, mraa_boolean_t mmap_en)
 {
     if (dev == NULL) {
         syslog(LOG_ERR, "gpio: use_mmaped: context is invalid");
@@ -1738,6 +1756,12 @@ mraa_gpio_use_mmaped(mraa_gpio_context dev, mraa_boolean_t mmap_en)
     return MRAA_ERROR_FEATURE_NOT_IMPLEMENTED;
 }
 
+mraa_result_t
+mraa_gpio_use_mmaped(mraa_gpio_context dev, mraa_boolean_t mmap_en)
+{
+    return mraa_gpio_use_mmaped_internal(dev, mmap_en);
+}
+
 int
 mraa_gpio_get_pin(mraa_gpio_context dev)
 {
diff --git a/src/iio/iio.c b/src/iio/iio.c
index 35162a9..26f116a 100644
--- a/src/iio/iio.c
+++ b/src/iio/iio.c
@@ -162,7 +162,7 @@ mraa_iio_get_channel_data(mraa_iio_context dev)
 
         if(chan->bytes <= 0)
         {
-            syslog(LOG_ERR, "iio: Channel %d with channel bytes value <= 0");
+            syslog(LOG_ERR, "iio: Channel %d with channel bytes value <= 0", i);
             return MRAA_IO_SETUP_FAILURE;
         }
 
diff --git a/src/led/led.c b/src/led/led.c
index 2c5fc94..1b04943 100644
--- a/src/led/led.c
+++ b/src/led/led.c
@@ -69,6 +69,10 @@ mraa_led_get_maxbrightfd(mraa_led_context dev)
 static mraa_led_context
 mraa_led_init_internal(const char* led)
 {
+    char brightness_path[MAX_SIZE];
+    const char *led_name = NULL;
+    char *led_path;
+    size_t led_path_len;
     DIR* dir;
     struct dirent* entry;
     int cnt = 0;
@@ -79,7 +83,6 @@ mraa_led_init_internal(const char* led)
         return NULL;
     }
 
-    dev->led_name = NULL;
     dev->trig_fd = -1;
     dev->bright_fd = -1;
     dev->max_bright_fd = -1;
@@ -88,13 +91,14 @@ mraa_led_init_internal(const char* led)
         /* get the led name from sysfs path */
         while ((entry = readdir(dir)) != NULL) {
             if (strstr((const char*) entry->d_name, led)) {
-                dev->led_name = (char*) entry->d_name;
+                led_name = entry->d_name;
+                break;
             }
             cnt++;
         }
     }
     dev->count = cnt;
-    if (dev->led_name == NULL) {
+    if (led_name == NULL) {
         syslog(LOG_CRIT, "led: init: unknown device specified");
         if (dir != NULL) {
             closedir(dir);
@@ -103,19 +107,28 @@ mraa_led_init_internal(const char* led)
         return NULL;
     }
 
-    if (dir != NULL) {
+    led_path_len = strlen(SYSFS_CLASS_LED) + strlen(led_name) + 3;
+    led_path = calloc(led_path_len, sizeof(char));
+    if (led_path == NULL) {
+        syslog(LOG_CRIT, "led: init: Failed to allocate memory for LED path");
         closedir(dir);
+        return NULL;
+    }
+    snprintf(led_path, led_path_len, "%s/%s", SYSFS_CLASS_LED, led_name);
+    dev->led_path = led_path;
+
+    snprintf(brightness_path, sizeof(brightness_path), "%s/%s", led_path, "brightness");
+    if (access(brightness_path, R_OK | W_OK) != 0) {
+        syslog(LOG_NOTICE, "led: init: current user doesn't have access rights for using LED %s", led_name);
     }
+
+    closedir(dir);
     return dev;
 }
 
 mraa_led_context
 mraa_led_init(int index)
 {
-    mraa_led_context dev = NULL;
-    char directory[MAX_SIZE];
-    struct stat dir;
-
     if (plat == NULL) {
         syslog(LOG_ERR, "led: init: platform not initialised");
         return NULL;
@@ -136,27 +149,12 @@ mraa_led_init(int index)
         return NULL;
     }
 
-    dev = mraa_led_init_internal((char*) plat->led_dev[index].name);
-    if (dev == NULL) {
-        return NULL;
-    }
-
-    snprintf(directory, MAX_SIZE, "%s/%s", SYSFS_CLASS_LED, dev->led_name);
-    if (stat(directory, &dir) == 0 && S_ISDIR(dir.st_mode)) {
-        syslog(LOG_NOTICE, "led: init: current user doesn't have access rights for using LED %s", dev->led_name);
-    }
-    strncpy(dev->led_path, (const char*) directory, sizeof(directory));
-
-    return dev;
+    return mraa_led_init_internal((char*) plat->led_dev[index].name);
 }
 
 mraa_led_context
 mraa_led_init_raw(const char* led)
 {
-    mraa_led_context dev = NULL;
-    char directory[MAX_SIZE];
-    struct stat dir;
-
     if (plat == NULL) {
         syslog(LOG_ERR, "led: init: platform not initialised");
         return NULL;
@@ -167,18 +165,7 @@ mraa_led_init_raw(const char* led)
         return NULL;
     }
 
-    dev = mraa_led_init_internal(led);
-    if (dev == NULL) {
-        return NULL;
-    }
-
-    snprintf(directory, MAX_SIZE, "%s/%s", SYSFS_CLASS_LED, dev->led_name);
-    if (stat(directory, &dir) == 0 && S_ISDIR(dir.st_mode)) {
-        syslog(LOG_NOTICE, "led: init: current user don't have access rights for using LED %s", dev->led_name);
-    }
-    strncpy(dev->led_path, (const char*) directory, sizeof(directory));
-
-    return dev;
+    return mraa_led_init_internal(led);
 }
 
 mraa_result_t
@@ -402,6 +389,7 @@ mraa_led_close(mraa_led_context dev)
         close(dev->max_bright_fd);
     }
 
+    free((void *)dev->led_path);
     free(dev);
 
     return MRAA_SUCCESS;
diff --git a/src/python/python3/CMakeLists.txt b/src/python/python3/CMakeLists.txt
index 03894cf..c8de846 100644
--- a/src/python/python3/CMakeLists.txt
+++ b/src/python/python3/CMakeLists.txt
@@ -25,7 +25,7 @@ endif ()
 
 set_target_properties (${SWIG_MODULE_python3-mraa_REAL_NAME} PROPERTIES
   OUTPUT_NAME _mraa
-  COMPILE_FLAGS "${CMAKE_C_FLAGS} -DSWIGPYTHON=${SWIG_FOUND} -DSWIGPYTHON3=${SWIG_FOUND}"
+  COMPILE_FLAGS "-DSWIGPYTHON=${SWIG_FOUND} -DSWIGPYTHON3=${SWIG_FOUND}"
 )
 
 install (TARGETS ${SWIG_MODULE_python3-mraa_REAL_NAME}
diff --git a/src/uart/uart.c b/src/uart/uart.c
index f1a76d2..36517fa 100644
--- a/src/uart/uart.c
+++ b/src/uart/uart.c
@@ -337,7 +337,7 @@ mraa_uart_stop(mraa_uart_context dev)
 }
 
 mraa_result_t
-mraa_uart_settings(int index, const char **devpath, const char **name, int* baudrate, int* databits, int* stopbits, mraa_uart_parity_t* parity, unsigned int* ctsrts, unsigned int* xonxoff) {
+mraa_uart_settings(int index, const char **devpath, const char **name, int* baudrate, int* databits, int* stopbits, mraa_uart_parity_t* parity, mraa_boolean_t* ctsrts, mraa_boolean_t* xonxoff) {
     struct termios term;
     int fd;
 
@@ -415,11 +415,11 @@ mraa_uart_settings(int index, const char **devpath, const char **name, int* baud
        }
 
        if (ctsrts != NULL) {
-           *ctsrts = term.c_cflag & CRTSCTS;
+           *ctsrts = (term.c_cflag & CRTSCTS) != 0;
        }
 
        if (xonxoff != NULL) {
-           *xonxoff = term.c_iflag & (IXON|IXOFF);
+           *xonxoff = (term.c_iflag & (IXON|IXOFF)) != 0;
        }
 
        close(fd);
@@ -616,16 +616,6 @@ mraa_uart_set_flowcontrol(mraa_uart_context dev, mraa_boolean_t xonxoff, mraa_bo
         }
     }
 
-    // hardware flow control
-    int action = TCIOFF;
-    if (xonxoff) {
-        action = TCION;
-    }
-    if (tcflow(dev->fd, action)) {
-        return MRAA_ERROR_FEATURE_NOT_SUPPORTED;
-    }
-
-    // rtscts
     struct termios termio;
 
     // get current modes
@@ -634,6 +624,12 @@ mraa_uart_set_flowcontrol(mraa_uart_context dev, mraa_boolean_t xonxoff, mraa_bo
          return MRAA_ERROR_INVALID_RESOURCE;
     }
 
+    if (xonxoff) {
+        termio.c_iflag |= IXON|IXOFF;
+    } else {
+        termio.c_iflag &= ~(IXON|IXOFF);
+    }
+
     if (rtscts) {
         termio.c_cflag |= CRTSCTS;
     } else {
diff --git a/src/x86/intel_ilk.c b/src/x86/intel_ilk.c
new file mode 100644
index 0000000..e71817d
--- /dev/null
+++ b/src/x86/intel_ilk.c
@@ -0,0 +1,439 @@
+/*
+ * Author: Jeet Arora <jeet.arora@intel.com>
+ * Copyright (c) 2021 Intel Corporation.
+ *
+ * SPDX-License-Identifier: MIT
+ */
+
+#include <dirent.h>
+#include <mraa/common.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdbool.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/mman.h>
+
+#include <fcntl.h>
+
+#include "common.h"
+#include "x86/intel_ilk.h"
+
+#define PLATFORM_NAME "Intel Learning Kit"
+
+mraa_board_t*
+mraa_intel_ilk()
+{
+    int pin_num = 0;
+
+    mraa_board_t* b = (mraa_board_t*) calloc(1, sizeof(mraa_board_t));
+    if (b == NULL) {
+        return NULL;
+    }
+
+    b->platform_name = PLATFORM_NAME;
+    b->phy_pin_count = MRAA_INTEL_ILK_PINCOUNT;
+    b->aio_count = 0;
+    b->adc_raw = 0;
+    b->adc_supported = 0;
+
+    b->pins = (mraa_pininfo_t*) malloc(sizeof(mraa_pininfo_t) * MRAA_INTEL_ILK_PINCOUNT);
+    if (b->pins == NULL) {
+        goto error;
+    }
+
+    b->adv_func = (mraa_adv_func_t*) calloc(1, sizeof(mraa_adv_func_t));
+    if (b->adv_func == NULL) {
+        free(b->pins);
+        goto error;
+    }
+
+    b->chardev_capable = 1;
+
+    // UART-1
+    b->uart_dev_count = 1;
+    b->def_uart_dev = 0;
+    b->uart_dev[0].rx = 10;
+    b->uart_dev[0].tx = 8;
+    b->uart_dev[0].device_path = "/dev/ttyS4";
+
+    // UART-2
+    b->uart_dev_count = 2;
+    b->def_uart_dev = 1;
+    b->uart_dev[1].rx = 13;
+    b->uart_dev[1].tx = 15;
+    b->uart_dev[1].device_path = "/dev/ttyS5";
+
+    // BUS DEFINITIONS
+    b->i2c_bus_count = 1;
+    b->def_i2c_bus = 0;
+    b->i2c_bus[b->i2c_bus_count].bus_id = 1;
+    b->i2c_bus[b->i2c_bus_count].sda = 3;
+    b->i2c_bus[b->i2c_bus_count].scl = 5;
+
+    // BUS DEFINITIONS
+    b->i2c_bus_count = 2;
+    b->def_i2c_bus = 0;
+    b->i2c_bus[b->i2c_bus_count].bus_id = 2;
+    b->i2c_bus[b->i2c_bus_count].sda = 18;
+    b->i2c_bus[b->i2c_bus_count].scl = 16;
+
+    // BUS DEFINITIONS
+    b->i2c_bus_count = 3;
+    b->def_i2c_bus = 0;
+    b->i2c_bus[b->i2c_bus_count].bus_id = 3;
+    b->i2c_bus[b->i2c_bus_count].sda = 22;
+    b->i2c_bus[b->i2c_bus_count].scl = 11;
+
+    // BUS DEFINITIONS
+    b->i2c_bus_count = 4;
+    b->def_i2c_bus = 0;
+    b->i2c_bus[b->i2c_bus_count].bus_id = 4;
+    b->i2c_bus[b->i2c_bus_count].sda = 27;
+    b->i2c_bus[b->i2c_bus_count].scl = 28;
+
+    b->i2c_bus_count = 5;
+
+    // Pin number 0
+    strncpy(b->pins[pin_num].name, "INVALID", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 0, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 1
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "3V3", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 2
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "5V", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 3
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "I2C1_SDA", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  414 + 60;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].i2c.pinmap = 0;
+    b->pins[pin_num].i2c.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 60;
+
+    // Pin number 4
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "5V", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 5
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "I2C1_SCL", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  414 + 63;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].i2c.pinmap = 0;
+    b->pins[pin_num].i2c.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 63;
+
+    // Pin number 6
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GND", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 7
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO4", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap = 228 + 7;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 3;
+    b->pins[pin_num].gpio.gpio_line = 7;
+
+    // Pin number 8
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "UART1_TX", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 };
+    b->pins[pin_num].gpio.pinmap = 414 + 20;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].uart.parent_id = 0;
+    b->pins[pin_num].uart.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 20;
+
+    // Pin number 9
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GND", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 10
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "UART1_RX", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 };
+    b->pins[pin_num].gpio.pinmap = 414 + 16;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].uart.parent_id = 0;
+    b->pins[pin_num].uart.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 16;
+
+    // Pin number 11
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "I2C3_SCL", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  414 + 67;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 67;
+
+    // Pin number 12
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO_BCLK", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap = 414 + 92;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 92;
+
+    // Pin number 13
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "UART2_RX", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].gpio.pinmap = 414 + 17;
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 };
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].uart.parent_id = 0;
+    b->pins[pin_num].uart.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 17;
+
+    // Pin number 14
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GND", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 15
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "UART2_TX", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 1 };
+    b->pins[pin_num].gpio.pinmap =  414 + 21;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].uart.parent_id = 0;
+    b->pins[pin_num].uart.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 21;
+
+    // Pin number 16
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "I2C4_SCL", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =   414 + 50;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 50;
+
+    // Pin number 17
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "3V3", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 18
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "I2C4_SDA", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  414 + 46;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 46;
+
+    // Pin number 19
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO6", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap = 228 + 64;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 3;
+    b->pins[pin_num].gpio.gpio_line = 64;
+
+    // Pin number 20
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GND", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 21
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO7", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  228 + 60;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 3;
+    b->pins[pin_num].gpio.gpio_line = 60;
+
+    // Pin number 22
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "I2C3_SDA", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  414 + 64;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 64;
+
+    // Pin number 23
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO8", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  228 + 62;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 3;
+    b->pins[pin_num].gpio.gpio_line = 62;
+
+    // Pin number 24
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO21", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  228 + 66;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 3;
+    b->pins[pin_num].gpio.gpio_line = 66;
+
+    // Pin number 25
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GND", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 26
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO22", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap = 228 + 61;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 3;
+    b->pins[pin_num].gpio.gpio_line = 61;
+
+    // Pin number 27
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "I2C2_SDA", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 0, 0 };
+    b->pins[pin_num].gpio.pinmap = 414 + 62;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 62;
+
+    // Pin number 28
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "I2C2_SCL", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 1, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  414 + 66;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 66;
+
+    // Pin number 29
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO1", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  228 + 6;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 3;
+    b->pins[pin_num].gpio.gpio_line = 6;
+
+    // Pin number 30
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GND", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 31
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO_MCLK", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  228 + 0;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 3;
+    b->pins[pin_num].gpio.gpio_line = 0;
+
+    // Pin number 32
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO24", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  228 + 5;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 3;
+    b->pins[pin_num].gpio.gpio_line = 5;
+
+    // Pin number 33
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO12", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  228 + 1;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 3;
+    b->pins[pin_num].gpio.gpio_line = 1;
+
+    // Pin number 34
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GND", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 35
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO_LRCLK", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  414 + 96;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 96;
+
+    // Pin number 36
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO16", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  228 + 3;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 3;
+    b->pins[pin_num].gpio.gpio_line = 3;
+
+    // Pin number 37
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO19", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  228 + 4;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 3;
+    b->pins[pin_num].gpio.gpio_line = 4;
+
+    // Pin number 38
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO_DIN", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  414 + 94;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 94;
+
+    // Pin number 39
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GND", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 0, 0, 0, 0, 0, 0, 0 };
+
+    // Pin number 40
+    pin_num += 1;
+    strncpy(b->pins[pin_num].name, "GPIO_DOUT", MRAA_PIN_NAME_SIZE);
+    b->pins[pin_num].capabilities = (mraa_pincapabilities_t){ 1, 1, 0, 0, 0, 0, 0, 0 };
+    b->pins[pin_num].gpio.pinmap =  414 + 97;
+    b->pins[pin_num].gpio.mux_total = 0;
+    b->pins[pin_num].gpio.gpio_chip = 0;
+    b->pins[pin_num].gpio.gpio_line = 97;
+
+    b->gpio_count = 0;
+    int i;
+    for (i = 0; i < b->phy_pin_count; i++) {
+        if (b->pins[i].capabilities.gpio) {
+            b->gpio_count++;
+        }
+    }
+
+    return b;
+
+error:
+    syslog(LOG_CRIT, "Intel Learning Kit: Platform failed to initialise");
+    free(b);
+    return NULL;
+}
diff --git a/src/x86/x86.c b/src/x86/x86.c
index 262682d..9feee4f 100644
--- a/src/x86/x86.c
+++ b/src/x86/x86.c
@@ -19,6 +19,7 @@
 #include "x86/intel_minnow_byt_compatible.h"
 #include "x86/intel_sofia_3gr.h"
 #include "x86/intel_cherryhills.h"
+#include "x86/intel_ilk.h"
 #include "x86/up.h"
 #include "x86/up2.h"
 #include "x86/intel_joule_expansion.h"
@@ -78,6 +79,9 @@ mraa_x86_platform()
             } else if (strncasecmp(line, "Braswell Cherry Hill", strlen("Braswell Cherry Hill") + 1) == 0) {
                 platform_type = MRAA_INTEL_CHERRYHILLS;
                 plat = mraa_intel_cherryhills();
+            } else if (strncasecmp(line, "Intel Learning Kit", strlen("Intel Learning Kit") + 1) == 0) {
+                platform_type = MRAA_INTEL_ILK;
+                plat = mraa_intel_ilk();
             } else if (strncasecmp(line, "UP-CHT01", strlen("UP-CHT01") + 1) == 0) {
                 platform_type = MRAA_UP;
                 plat = mraa_up_board();
diff --git a/tools/mraa-gpio.c b/tools/mraa-gpio.c
index 4e0f081..05b9316 100644
--- a/tools/mraa-gpio.c
+++ b/tools/mraa-gpio.c
@@ -96,7 +96,7 @@ gpio_set(int pin, int level, mraa_boolean_t raw)
     if (gpio != NULL) {
         mraa_gpio_dir(gpio, MRAA_GPIO_OUT);
         if (raw != 0) {
-            if (mraa_gpio_use_mmaped(gpio, 1) != MRAA_SUCCESS) {
+            if (mraa_gpio_use_mmaped_internal(gpio, 1) != MRAA_SUCCESS) {
                 fprintf(stdout,
                         "mmapped access to gpio %d not supported, falling back to normal mode\n", pin);
             }
@@ -114,7 +114,7 @@ gpio_get(int pin, int* level, mraa_boolean_t raw)
     if (gpio != NULL) {
         mraa_gpio_dir(gpio, MRAA_GPIO_IN);
         if (raw != 0) {
-            if (mraa_gpio_use_mmaped(gpio, 1) != MRAA_SUCCESS) {
+            if (mraa_gpio_use_mmaped_internal(gpio, 1) != MRAA_SUCCESS) {
                 fprintf(stdout,
                         "mmapped access to gpio %d not supported, falling back to normal mode\n", pin);
             }
diff --git a/tools/mraa-uart.c b/tools/mraa-uart.c
index 77123f5..384f13b 100644
--- a/tools/mraa-uart.c
+++ b/tools/mraa-uart.c
@@ -106,7 +106,7 @@ main(int argc, const char** argv) {
 
     int baudrate = 115200, stopbits = 1, databits = 8;
     mraa_uart_parity_t parity = MRAA_UART_PARITY_NONE;
-    unsigned int ctsrts = FALSE, xonxoff = FALSE;
+    mraa_boolean_t ctsrts = FALSE, xonxoff = FALSE;
     const char *name = NULL, *dev = NULL;
 
     double recieve_timeout = 0.0;
-- 
2.32.0

